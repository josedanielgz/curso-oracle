<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>9&period;1 Uso de las Cl&aacute;usulas Group By y Having</title>
        <style>
</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        
        
    </head>
    <body class="vscode-body vscode-light">
         <title>Oracle Academy: Database Programing with SQL, Parte 9</title>
<ul>
<li><a href="index.html">Volver al inicio</a></li>
</ul>
<ul>
<li><a href="#91-uso-de-las-cl%C3%A1usulas-group-by-y-having">9.1 Uso de las Cláusulas Group By y Having</a>
<ul>
<li><a href="#cl%C3%A1usula-group-by">Cláusula GROUP BY</a></li>
<li><a href="#count">COUNT</a></li>
<li><a href="#cl%C3%A1usula-where">Cláusula WHERE</a></li>
<li><a href="#grupos-dentro-de-grupos">Grupos dentro de Grupos</a></li>
<li><a href="#anidamiento-de-funciones-de-grupo">Anidamiento de Funciones de Grupo</a></li>
<li><a href="#having">HAVING</a></li>
</ul>
</li>
<li><a href="#92-uso-de-las-operaciones-roullup-y-cube-y-grouping-sets">9.2 Uso de las Operaciones Roullup y Cube, y Grouping Sets</a>
<ul>
<li><a href="#f%C3%B3rmula-de-resultado-de-rollup">Fórmula de Resultado de ROLLUP</a></li>
<li><a href="#sin-rollup">Sin ROLLUP</a></li>
<li><a href="#cube">CUBE</a></li>
<li><a href="#grouping-sets">GROUPING SETS</a></li>
<li><a href="#funciones-grouping">Funciones GROUPING</a></li>
</ul>
</li>
<li><a href="#93-uso-de-los-operadores-set">9.3 Uso de los Operadores SET</a>
<ul>
<li><a href="#union">UNION</a></li>
<li><a href="#intersect">INTERSECT</a></li>
<li><a href="#minus">MINUS</a></li>
<li><a href="#ejemplos-de-operadores-set">Ejemplos de Operadores SET</a></li>
</ul>
</li>
</ul>
<h2 id="91-uso-de-las-cláusulas-group-by-y-having">9.1 Uso de las Cláusulas Group By y Having</h2>
<p>Existen casos en los que además de formar grupos con los datos también se
requiere clasificar esos grupo, por ejemplo, al intentar averiguar el promedio
de altura de los estudiantes de cada curso en una institución educativa. Este
problema podría resolverse utilizando la siguiente consulta:</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">AVG</span>(height) <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> year_in_school=:insert_year_in_school;
</div></code></pre>
<p>Pero, a parte de ser una sentencia que probablemente no funcionaría fuera de
Oracle APEX, habría que insertar cada curso por separado a mano. La otra opción
es crear una sentencia individual para cada <code>year_in_school</code>, pero eso es
engorroso. Por suerte las cláusulas <code>GROUP BY</code> y <code>HAVING</code> pueden utilizarse juntas
para manipular las funciones de grupo. Por ejemplo:</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> department_id, <span class="hljs-keyword">AVG</span>(salary) <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id <span class="hljs-keyword">ORDER</span>
<span class="hljs-keyword">BY</span> department_id;
</div></code></pre>
<p>La sentencia anterior calcula el promedio de salario de los empleados de cada
departamento <strong>PERO AGRUPANDO TODOS LOS EMPLEADOS POR SU DEPARTAMENTO.</strong> Esto
arrojaría la siguente respuesta:</p>
<table>
<thead>
<tr>
<th>DEPARTMENT_ID</th>
<th>AVG(SALARY)</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>4400</td>
</tr>
<tr>
<td>20</td>
<td>9500</td>
</tr>
<tr>
<td>50</td>
<td>3500</td>
</tr>
<tr>
<td>60</td>
<td>6400</td>
</tr>
<tr>
<td>80</td>
<td>10033.33333333...</td>
</tr>
<tr>
<td>90</td>
<td>10033.33333333...</td>
</tr>
<tr>
<td>110</td>
<td>10150</td>
</tr>
<tr>
<td>-</td>
<td>7000</td>
</tr>
</tbody>
</table>
<p><strong>Lo que sucede es que, primero se agrupan todos los empleados por
<code>department_id</code>, y luego se le aplica la función <code>AVG</code> a cada grupo.</strong></p>
<p>Otro problema similar, averiguar cuál es el salario máximo entre los empleados
por cada departamento.</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MAX</span>(salary) <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id;
</div></code></pre>
<table>
<thead>
<tr>
<th>MAX(SALARY)</th>
</tr>
</thead>
<tbody>
<tr>
<td>7000</td>
</tr>
<tr>
<td>24000</td>
</tr>
<tr>
<td>13000</td>
</tr>
<tr>
<td>...</td>
</tr>
</tbody>
</table>
<h3 id="cláusula-group-by">Cláusula GROUP BY</h3>
<p>¿Pero qué pasa si se necesita saber de qué departamento proviene cada salario
máximo? Eso es posible, sólo hay que incluir la columna <code>department_id</code> en la
cláusula <code>GROUP BY</code>.</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> department_id,<span class="hljs-keyword">MAX</span>(salary) <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id;
</div></code></pre>
<table>
<thead>
<tr>
<th>DEPARTMENT_ID</th>
<th>MAX(SALARY)</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>7000</td>
</tr>
<tr>
<td>90</td>
<td>24000</td>
</tr>
<tr>
<td>20</td>
<td>13000</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<p>Aunque hay una salvedad: <strong>CUALQUIER COLUMNA QUE NO FORME PARTE DE UNA FUNCIÓN
DE GRUPO Y SE ENCUENTRE EN LA CLÁUSULA <code>SELECT</code> DEBE HACER PARTE DE LA CLÁUSULA
<code>GROUP BY</code>, en caso contrario se generará un error:</strong></p>
<pre><code class="language-sql"><div><span class="hljs-comment">-- la siguiente sentencia devuelve error por el las_name en la cláusula SELECT</span>
<span class="hljs-keyword">SELECT</span> job_id, last_name, <span class="hljs-keyword">AVG</span>(salary) <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job_id;
</div></code></pre>
<p>Otros ejemplos del uso de <code>GROUP BY</code>:</p>
<p>Redondear la media a un número entero:</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> region_id, <span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">AVG</span>(population)) <span class="hljs-keyword">AS</span> population, <span class="hljs-keyword">FROM</span> wf_countries <span class="hljs-keyword">GROUP</span>
<span class="hljs-keyword">BY</span> region_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> region_id;
</div></code></pre>
<p>Cuente el número de idiomas hablados para todos los países:</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> country_id, <span class="hljs-keyword">COUNT</span>(language_id) <span class="hljs-keyword">AS</span> <span class="hljs-string">&quot;Number of languages&quot;</span> <span class="hljs-keyword">FROM</span>
wf_spoken_languages <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> country_id;
</div></code></pre>
<h3 id="count">COUNT</h3>
<p>En este ejemplo se muestra cuántos países hay en cada región.</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(country_name), region_id <span class="hljs-keyword">FROM</span> wf_countries <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> region_id
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> region_id;
</div></code></pre>
<p>Esta consulta retorna la siguiente tabla:</p>
<table>
<thead>
<tr>
<th>COUNT(COUNTRY_NAME)</th>
<th>REGION_ID</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
<td>5</td>
</tr>
<tr>
<td>28</td>
<td>9</td>
</tr>
<tr>
<td>21</td>
<td>11</td>
</tr>
<tr>
<td>8</td>
<td>13</td>
</tr>
<tr>
<td>7</td>
<td>14</td>
</tr>
<tr>
<td>8</td>
<td>15</td>
</tr>
<tr>
<td>5</td>
<td>17</td>
</tr>
<tr>
<td>17</td>
<td>18</td>
</tr>
</tbody>
</table>
<p>Aunque por regla general (incluso si es poco probable en este caso) es mejor
utilizar <code>COUNT(*)</code> para eliminar cualquier posibilidad de encontrarse con
nulos.</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(*), region_id <span class="hljs-keyword">FROM</span> wf_countries <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> region_id
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> region_id;
</div></code></pre>
<h3 id="cláusula-where">Cláusula WHERE</h3>
<p>También se pueden utilizar cláusulas WHERE para excluir las filas <strong>antes de
que estas formen grupos. NO SE PUEDEN USAR CLÁUSULAS WHERE DESPUÉS DE UN <code>GROUP BY</code></strong></p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> department_id, <span class="hljs-keyword">MAX</span>(salary) <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> last_name!=<span class="hljs-string">&#x27;King&#x27;</span> <span class="hljs-keyword">GROUP</span>
<span class="hljs-keyword">BY</span> department_id;
</div></code></pre>
<p>Eso devolvería:</p>
<table>
<thead>
<tr>
<th>DEPARTMENT_ID</th>
<th>MAX(SALARY)</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>7000</td>
</tr>
<tr>
<td>90</td>
<td>24000</td>
</tr>
<tr>
<td>20</td>
<td>13000</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<h3 id="grupos-dentro-de-grupos">Grupos dentro de Grupos</h3>
<p>A veces se debe dividir los grupos en subgrupos aún más pequeños, por ejemplo,
para agrupar todos los empleados por su departamento, y luego, dentro de cada
departamento, agruparlos por trabajo. Tal caso se puede apreciar en la
siguiente consulta:</p>
<pre><code class="language-sql"><div><span class="hljs-comment">-- nótese los dos argumentos de la cláusula GROUP BY.</span>
<span class="hljs-comment">-- primero está agrupando a todos los empleados por departamantos</span>
<span class="hljs-comment">-- luego, cuando estén agrupados, los subagrupa por trabajo</span>
<span class="hljs-keyword">SELECT</span> department_id, job_id, <span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> department_id&gt;<span class="hljs-number">40</span>
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id, job_id;
</div></code></pre>
<p>Dicha consulta devuelve:</p>
<table>
<thead>
<tr>
<th>DEPARTMENT_ID</th>
<th>JOB_ID</th>
<th>COUNT(*)</th>
</tr>
</thead>
<tbody>
<tr>
<td>110</td>
<td>AC_ACCOUNT</td>
<td>1</td>
</tr>
<tr>
<td>50</td>
<td>ST_CLERK</td>
<td>4</td>
</tr>
<tr>
<td>80</td>
<td>SA_REP</td>
<td>2</td>
</tr>
<tr>
<td>90</td>
<td>AD_VP</td>
<td>2</td>
</tr>
<tr>
<td>50</td>
<td>ST_MAN</td>
<td>1</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>
<h3 id="anidamiento-de-funciones-de-grupo">Anidamiento de Funciones de Grupo</h3>
<p>Las funciones de grupo se pueden anidar <strong>EN UNA PROFUNDIDAD DE DOS</strong> cuando se
utilice un <code>GROUP BY</code>. Por ejemplo:</p>
<pre><code class="language-sql"><div><span class="hljs-comment">-- máximo dos funciones de grupo anidadas a la vez</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MAX</span>(<span class="hljs-keyword">AVG</span>(salary)) <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id;
</div></code></pre>
<p>La consulta anterior devuelve un valor: el salario promedio más alto entre
todos los departamentos.</p>
<h3 id="having">HAVING</h3>
<p>Existen escenarios donde se nota quea cláusula WHERE tiene sus limitaciones a
la hora de trabajar con grupos. Por ejemplo, a primera vista no parece difícil
resolver el problema de encontrar el salario más alto de cada departamento que
tenga más de un empleado, PERO <strong>la siguiente sentencia NO es
posible realizarla:</strong></p>
<pre><code class="language-sql"><div><span class="hljs-comment">-- NO SE PUEDEN UTILIZAR FUNCIONES DE GRUPO EN UN WHERE CON UN GROUP BY</span>
<span class="hljs-keyword">SELECT</span> department_id, <span class="hljs-keyword">MAX</span>(salary) <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">count</span>(*)&gt;<span class="hljs-number">1</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>
department_id;
<span class="hljs-comment">-- arroja error</span>
</div></code></pre>
<p>Por suerte existe una cláusua especial para restringir los grupos, <code>HAVING</code>. En
una consulta con una cláusula <code>GROUP BY</code> y <code>HAVING</code>, primero se crean los
grupos y luego se filtran. La forma correcta de realizar la consulta anterior,
sería:</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> department_id, <span class="hljs-keyword">MAX</span>(salary) <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id <span class="hljs-keyword">HAVING</span>
<span class="hljs-keyword">COUNT</span>(*)&gt;<span class="hljs-number">1</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> department_id;
</div></code></pre>
<table>
<thead>
<tr>
<th>DEPARTMENT_ID</th>
<th>MAX(SALARY)</th>
</tr>
</thead>
<tbody>
<tr>
<td>20</td>
<td>13000</td>
</tr>
<tr>
<td>50</td>
<td>5800</td>
</tr>
<tr>
<td>60</td>
<td>9000</td>
</tr>
<tr>
<td>80</td>
<td>11000</td>
</tr>
<tr>
<td>90</td>
<td>24000</td>
</tr>
<tr>
<td>110</td>
<td>12000</td>
</tr>
</tbody>
</table>
<p>La siguiente consulta devuelve la población media de los países de cada región,
pero sólo de los grupos de regiones con una población superior a 300 mil:</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> region_id, <span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">AVG</span>(population)) <span class="hljs-keyword">FROM</span> wf_countries <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> region_id
<span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">MIN</span>(population)&gt;<span class="hljs-number">300000</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> region_id;
</div></code></pre>
<p><strong>Se recomienda seguir el siguiente orden a la hora de utilizar las cláusulas para
manipular grupos:</strong></p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> colummn, group_function <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> ... <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> ... <span class="hljs-keyword">HAVING</span> ...
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> ...;
</div></code></pre>
<h2 id="92-uso-de-las-operaciones-roullup-y-cube-y-grouping-sets">9.2 Uso de las Operaciones Roullup y Cube, y Grouping Sets</h2>
<p>En ocasiones, además de obtener los datos agrupados, se requiere realizar
cálculos con ellos, algunos de ellos incluso acumulativos. Por ejemplo,
evaluando el caso de la altura promedio de los estudiantes de una institución
por curso:</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> year_in_school, <span class="hljs-keyword">AVG</span>(height) <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> year_in_school;
</div></code></pre>
<p>¿Pero qué ocurre si, una vez que haya seleccionado sus grupos y calculado los
valores agregados en esos grupos, también deseara los subtotales por grupo y
una suma total de todas las filas seleccionadas?. Existe la posibilidad de
importar los resultados en otros métodos externos como una hoja de cálculo o
una calculadora. Pero convenientemente, Oracle Server cuenta con algunas
extensiones de la cláusula GROUP BY creadas específicamente con este fin:
<code>ROLLUP</code>, <code>CUBE</code> y <code>GROUPING SETS</code>.</p>
<p>En las consultas con <code>GROUP BY</code> a menudo se deben producir subtotales y
totales, eso puede hacerse con <code>ROLLUP</code>. Esta sentencia crea subtotales que se
acumulan desde el nivel más detallado hasta la suma total, siguiendo la lista
de agrupamiento especificada en la cláusula <code>GROUP BY</code>.</p>
<p><code>ROLLUP</code> utiliza una lista ordenada de las columnas del agrupamiento en su
lista de argumentos. En primer lugar, calcula los valores de agregación
estándar especificados en la cláusula <code>GROUP BY</code>. A continuación crea subtotales
de nivel superior de forma progresiva, de derecha a izquierda  a través de la
lista de columnas del agrupamiento. Finalmente, crea la suma total.</p>
<p>Por ejemplo, la siguiente consulta:</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> department_id, job_id, <span class="hljs-keyword">SUM</span>(salary) <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> department_id&lt;<span class="hljs-number">50</span>
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">ROLLUP</span>(department_id, job_id);
</div></code></pre>
<p>Devuelve la siguiente tabla:</p>
<table>
<thead>
<tr>
<th>DEPARTMENT_ID</th>
<th>JOB_ID</th>
<th>SUM(SALARY)</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>AD_ASST</td>
<td>4400</td>
</tr>
<tr>
<td><strong>10</strong></td>
<td>-</td>
<td><strong>4400</strong></td>
</tr>
<tr>
<td>20</td>
<td>MK_MAN</td>
<td>1300</td>
</tr>
<tr>
<td>20</td>
<td>MK_REP</td>
<td>6000</td>
</tr>
<tr>
<td><strong>20</strong></td>
<td>-</td>
<td><strong>19000</strong></td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td><strong>23400</strong></td>
</tr>
</tbody>
</table>
<p>Prestar atención a las filas que fueron resaltadas en la elaboración del
documento:</p>
<ul>
<li>La segunda fila de la tabla es el subtotal del <code>dept_id</code> 10</li>
<li>La penúltima fila es el subtotal del <code>dept_id</code> 20</li>
<li>La última fila es la suma total de ambos subtotales.</li>
</ul>
<h3 id="fórmula-de-resultado-de-rollup">Fórmula de Resultado de ROLLUP</h3>
<p>El número de columnas o expresiones que aparecen en la lista de argumentos de
<code>ROLLUP</code> determina el número de agrupamientos. La fórmula es <code>(número de columnas)+1</code> donde el número de columnas es la cantidad de argumentos pasados a
<code>ROLLUP</code>. En el ejemplo anterior, se le pasaron dos argumentos a <code>ROLLUP</code>,
<code>department_id</code> y <code>job_id</code>, por eso se generaron tres filas de resultado (la
segunda, la penúltima y la última).</p>
<h3 id="sin-rollup">Sin ROLLUP</h3>
<p>¿Qué aspecto hubiera tenido la consulta anterior, pero sin haber utilizado
ROLLUP?</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> department_id, job_id, <span class="hljs-keyword">SUM</span>(salary) <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> department_id&lt;<span class="hljs-number">50</span>
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> (department_id, job_id);
</div></code></pre>
<p>La salida se vería así</p>
<table>
<thead>
<tr>
<th>DEPARTMENT_ID</th>
<th>JOB_ID</th>
<th>SUM(SALARY)</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>AD_ASST</td>
<td>4400</td>
</tr>
<tr>
<td>20</td>
<td>MK_MAN</td>
<td>1300</td>
</tr>
<tr>
<td>20</td>
<td>MK_REP</td>
<td>6000</td>
</tr>
</tbody>
</table>
<p>Para obtener los subtotales de ROLLUP habría falta hacer varias consultas más
sobre esta tabla temporal.</p>
<h3 id="cube">CUBE</h3>
<p><code>CUBE</code> es una extensión de la cláusula <code>GROUP BY</code>, que genera informes de
tabulación cruzada, que se puede aplicar a todas las funciones de agregación.
Las columnas especificadas en la cláusula <code>GROUP BY</code> están incluídas en
referencias cruzadas para crear un superjuego de grupos. Las funciones de
agregación especificadas en la lista <code>SELECT</code> se aplican a estos grupos para
crear valores de resumen para las filas superagregadas adicionales.</p>
<p>Todas las combinaciones posibles de filas se agregan con <code>CUBE</code>, si tiene n
columnas en la cláusula GROUP BY, habrá 2n posibles combinaciones de
superagregados. Matemáticamente, estas combinaciones forman un cubo de n
dimensiones, de ahí el nombre del operador. Esta cláusula se utiliza a menudo
en las consultas que usan columnas de tablas independientes.</p>
<p>Un ejemplo práctico sería consultar la tabla de ventas de una compañía como
Amazon. Un informe de tabulación cruzada normalmente solicitado podría incluis
subtotales para todas las combinaciones posibles de las ventas de un mes,
región y producto.</p>
<p>En la siguiente consulta, las filas resaltadas las genera la operación <code>CUBE</code>:</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> department_id, job_id, <span class="hljs-keyword">SUM</span>(salary) <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> department_id&lt;<span class="hljs-number">50</span>
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">CUBE</span>(department_id,job_id);
</div></code></pre>
<table>
<thead>
<tr>
<th>DEPARMENT_ID</th>
<th>JOB_ID</th>
<th>SUM(SALARY)</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>-</td>
<td><strong>23400</strong></td>
</tr>
<tr>
<td>-</td>
<td><strong>MK_MAN</strong></td>
<td><strong>13000</strong></td>
</tr>
<tr>
<td>-</td>
<td><strong>MK_REP</strong></td>
<td><strong>60000</strong></td>
</tr>
<tr>
<td>-</td>
<td><strong>AD_ASST</strong></td>
<td><strong>4400</strong></td>
</tr>
<tr>
<td><strong>10</strong></td>
<td>-</td>
<td><strong>4400</strong></td>
</tr>
<tr>
<td>10</td>
<td>AD_ASST</td>
<td>4400</td>
</tr>
<tr>
<td><strong>20</strong></td>
<td>-</td>
<td><strong>19000</strong></td>
</tr>
<tr>
<td>20</td>
<td>MK_MAN</td>
<td>13000</td>
</tr>
<tr>
<td>20</td>
<td>MK_REP</td>
<td>6000</td>
</tr>
</tbody>
</table>
<p>Las filas resaltadas de la tabla representan:</p>
<ul>
<li>Primera fila: Total del informe</li>
<li>Segunda fila: Subtotal de MK_MAN</li>
<li>Tercera fila: Subtotal de MK_REP</li>
<li>Cuarta fila: Subtotal de AD_ASST</li>
<li>Quinta fila: Subtotal de departamento 10</li>
<li>Septima fila: Subtotal de departamento 20:</li>
</ul>
<h3 id="grouping-sets">GROUPING SETS</h3>
<p>Esta es otra extensión de la cláusula <code>GROUP BY</code>, se utiliza para especificar
varias agrupaciones de datos, lo que proporciona la funcionalidad de tener
varias cláusulas <code>GROUP BY</code> en la misma sentencia <code>SELECT</code>.</p>
<p>Si desea ver los datos de la tabla <code>EMPLOYEES</code> agrupados por <code>(department_id,manager_id)</code>
pero también por <code>(department_id,manager_id)</code>, y por <code>(job_id,manager_id)</code>,
esto se puede lograr con <code>GROUPING SETS</code> sin necesidad de reescribir la
sentencia con tres <code>GROUP BY</code> diferentes.</p>
<p>La siguiente sentencia hace uso de <code>GROUPING SETS</code> para resolver el problema
planteado anteriormente:</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> department_id, job_id, manager_id, <span class="hljs-keyword">SUM</span>(salary) <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span>
department_id&lt;<span class="hljs-number">50</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">GROUPING</span> <span class="hljs-keyword">SETS</span>
((job_id, manager_id),(department_id, job_id),(department_id, manager_id));
</div></code></pre>
<table>
<thead>
<tr>
<th>DEPARTMENT_ID</th>
<th>JOB_ID</th>
<th>MANAGER_ID</th>
<th>SUM(SALARY)</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>MK_MAN</td>
<td>100</td>
<td>1000</td>
</tr>
<tr>
<td>-</td>
<td>MK_MAN</td>
<td>201</td>
<td>6000</td>
</tr>
<tr>
<td>-</td>
<td>AD_ASST</td>
<td>101</td>
<td>4400</td>
</tr>
<tr>
<td>10</td>
<td>AD_ASST</td>
<td>-</td>
<td>4400</td>
</tr>
<tr>
<td>20</td>
<td>MK_MAN</td>
<td>-</td>
<td>13000</td>
</tr>
<tr>
<td>20</td>
<td>MK_REP</td>
<td>-</td>
<td>6000</td>
</tr>
<tr>
<td>10</td>
<td>-</td>
<td>101</td>
<td>19000</td>
</tr>
<tr>
<td>20</td>
<td>-</td>
<td>100</td>
<td>13000</td>
</tr>
<tr>
<td>20</td>
<td>-</td>
<td>201</td>
<td>6000</td>
</tr>
</tbody>
</table>
<ul>
<li>Las primeras tres filas don del grupo (job_id, manager_id)</li>
<li>Las filas de la cuarta a la sexta son del grupo (department_id, job_id)</li>
<li>Las filas de las séptima a la novena son de (department_id, manager_id)</li>
</ul>
<h3 id="funciones-grouping">Funciones GROUPING</h3>
<p>Al utilizar <code>ROLLUP</code> o <code>CUBE</code> para crear informes con subtotales muy a menudo
también tiene que poder saber qué filas de la salida son las reales y cuáles
son producidas por <code>ROLLUP</code> o <code>CUBE</code>. Esto es algo que se puede resolver con
<code>GROUPING</code>. Esta función sólo acepta una columna como argumento, y devuelve 1
para una fila que ha sido calculada o 0 para una que ha sido devuelta de la
BD.</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> department_id, job_id, <span class="hljs-keyword">SUM</span>(salary)
  <span class="hljs-keyword">GROUPING</span>(department_id) <span class="hljs-keyword">AS</span> <span class="hljs-string">&quot;Dept sub total&quot;</span>,
  <span class="hljs-keyword">GROUPING</span>(job_id) <span class="hljs-keyword">AS</span> <span class="hljs-string">&quot;Job sub total&quot;</span>
<span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> department_id&lt;<span class="hljs-number">50</span>
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">CUBE</span>(department_id,job_id);
</div></code></pre>
<table>
<thead>
<tr>
<th>DEPARMENT_ID</th>
<th>JOB_ID</th>
<th>SUM(SALARY)</th>
<th>Dept sub total</th>
<th>Job sub total</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>-</td>
<td><strong>23400</strong></td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>-</td>
<td><strong>MK_MAN</strong></td>
<td><strong>13000</strong></td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>-</td>
<td><strong>MK_REP</strong></td>
<td><strong>60000</strong></td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>-</td>
<td><strong>AD_ASST</strong></td>
<td><strong>4400</strong></td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><strong>10</strong></td>
<td>-</td>
<td><strong>4400</strong></td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>AD_ASST</td>
<td>4400</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td><strong>20</strong></td>
<td>-</td>
<td><strong>19000</strong></td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>20</td>
<td>MK_MAN</td>
<td>13000</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>20</td>
<td>MK_REP</td>
<td>6000</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<h2 id="93-uso-de-los-operadores-set">9.3 Uso de los Operadores SET</h2>
<p>Los operadores SET se utilizan para combinar los resultados de diferentes
sentencias SELECT en una sola salida de resultado.</p>
<p>A veces se desea una salida de más de una tabla. Unir dos tablas devuelve un juego de filas que cumple con los criterios de unión, pero a veces los criterios de unión no son suficiente. Los operadores <code>SET</code> abarcan más. Pueden devolver las filas que se han encontrado en varias sentencias <code>SELECT</code>, las que estén en una tabla y no en otra, o bien las filas comunes en ambas sentencias.</p>
<p>Estos tienen reglas específicas:</p>
<ul>
<li><strong>EL NÚMERO DE COLUMNAS Y LOS TIPOS DE DATOS DEBEN SER IDÉNTICOS en todas las sentencias SELECT utilizadas en la consulta, aunque NO TIENEN QUE LLAMARSE IGUAL.</strong></li>
<li><strong>LOS NOMBRES DE COLUMNA de la salida SE TOMAN de los nombres de columna DEL PRIMER <code>SELECT</code></strong></li>
</ul>
<p>Para explicar los operadores <code>SET</code>, se utilizarán las siguiente listas:</p>
<pre><code class="language-sql"><div>A={a_id:1,2,3,4,5}
B={b_id:4,5,6,7,8}
</div></code></pre>
<h3 id="union">UNION</h3>
<p>El operador <code>UNION</code> devuelve todas las filas de ambas tablas, después de eliminar los duplicados:</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> a_id <span class="hljs-keyword">FROM</span> a <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> b_id <span class="hljs-keyword">FROM</span> b;
<span class="hljs-comment">-- devuelve &quot;1,2,3,4,5,6,7,8&quot;</span>
</div></code></pre>
<p>Para devolver todas las filas coincidentes en ambas tablas sin eliminar los duplicados, hay que agregar el operador <code>ALL</code>:</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> a_id <span class="hljs-keyword">FROM</span> a <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">SELECT</span> b_id <span class="hljs-keyword">FROM</span> b;
<span class="hljs-comment">-- devuelve &quot;1,2,3,4,5,4,5,6,7,8&quot; porque el 4 y el 5 son los elemntos</span>
<span class="hljs-comment">-- coincidentes en ambas tablas y aparecen una vez en cada tabla.</span>
</div></code></pre>
<h3 id="intersect">INTERSECT</h3>
<p>El operador <code>INTERSECT</code> devuelve todas las filas comunes a ambas tablas.</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> a_id <span class="hljs-keyword">FROM</span> a <span class="hljs-keyword">INTERSECT</span> <span class="hljs-keyword">SELECT</span> b_id <span class="hljs-keyword">FROM</span> b;
<span class="hljs-comment">-- devuelve &quot;4,5&quot;</span>
</div></code></pre>
<h3 id="minus">MINUS</h3>
<p>El operador <code>MINUS</code> devuelve todas las filas encontradas en la tabla de la
primera sentencia (de izquierda a derecha) pero no de la segunda.</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> a_id <span class="hljs-keyword">FROM</span> a <span class="hljs-keyword">MINUS</span> <span class="hljs-keyword">SELECT</span> b_id <span class="hljs-keyword">FROM</span> b;
<span class="hljs-comment">-- el resultado sería 1,2,3. Los elementos de A que no están en B</span>
</div></code></pre>
<p>Para obtener los elementos que están en B pero no en A, habría que consultar a
B primero:</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> b_id <span class="hljs-keyword">from</span> B <span class="hljs-keyword">MINUS</span> <span class="hljs-keyword">SELECT</span> a_id <span class="hljs-keyword">FROM</span> a;
<span class="hljs-comment">-- retorna 6,7,8. Los valores de B que no están en A</span>
</div></code></pre>
<h3 id="ejemplos-de-operadores-set">Ejemplos de Operadores SET</h3>
<p>Considere la tabla employees que tiene una fecha de contratación, un ID de
empleado y un ID de cargo.</p>
<p>La tabla del historial de cargos contiene el ID del empleado y del cargo, pero
no tiene una columna con fecha de contratación.</p>
<p>A primera vista no se puede usar un <code>SET</code> con todo lo necesario, las dos tablas comparten ID del empleado e ID de cargo, pero el historial de cargos no tiene fecha de inicio.</p>
<p>Sin embargo, se puede utilizar la función <code>TO_CHAR(NULL)</code> para crear columnas coincidentes,
como en el siguiente ejemplo</p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> hire_date, employee_id, job_id <span class="hljs-keyword">FROM</span> employees
  <span class="hljs-keyword">UNION</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">TO_DATE</span>(<span class="hljs-literal">NULL</span>), employee_id, job_id <span class="hljs-keyword">FROM</span> job_history
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> employee_id;
</div></code></pre>
<p>El truco consiste en generar una columna artifical usando las funciones de conversión
de acuerdo con los tipos de datos de las columnas que se necesiten en la otra
tabla para que los <code>SET</code> puedan realizarse correctamente.</p>
<p><strong>Nótese que para ordenar toda la consulta sólo sigue haciendo falta colocar un
<code>ORDER BY</code> al final de toda la sentencia.</strong></p>
<pre><code class="language-sql"><div><span class="hljs-keyword">SELECT</span> hire_date, employee_id, <span class="hljs-keyword">TO_DATE</span>(<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">AS</span> start_date, <span class="hljs-keyword">TO_DATE</span>(<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">AS</span>
end_date, job_id, department_id <span class="hljs-keyword">FROM</span> employees
  <span class="hljs-keyword">UNION</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">TO_DATE</span>(<span class="hljs-literal">NULL</span>), employee_id, start_date, end_date, job_id, department_id
<span class="hljs-keyword">FROM</span> job_history
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> employee_id;
</div></code></pre>
<p>El resultado final de esa sentencia sería:</p>
<table>
<thead>
<tr>
<th>HIRE_DATE</th>
<th>EMPLOYEE_ID</th>
<th>START_DATE</th>
<th>END_DATE</th>
<th>JOB_ID</th>
<th>DEPARTMENT_ID</th>
</tr>
</thead>
<tbody>
<tr>
<td>17-Jun-1987</td>
<td>100</td>
<td>-</td>
<td>-</td>
<td>AD_PRES</td>
<td>90</td>
</tr>
<tr>
<td>21-Sep-1989</td>
<td>101</td>
<td>-</td>
<td>-</td>
<td>AD_VP</td>
<td>90</td>
</tr>
<tr>
<td>-</td>
<td>101</td>
<td>21-Sep-1989</td>
<td>27-Oct-1993</td>
<td>AC_ACCOUNT</td>
<td>110</td>
</tr>
<tr>
<td>-</td>
<td>101</td>
<td>28-Oct-1993</td>
<td>15-Mar-1997</td>
<td>AC_MGR</td>
<td>110</td>
</tr>
<tr>
<td>13-Jan-1993</td>
<td>102</td>
<td>-</td>
<td>-</td>
<td>AD_VP</td>
<td>90</td>
</tr>
<tr>
<td>-</td>
<td>102</td>
<td>13-Jan-1993</td>
<td>24-Jul-1998</td>
<td>IT_PROG</td>
<td>60</td>
</tr>
<tr>
<td>03-Jan-1990</td>
<td>103</td>
<td>-</td>
<td>-</td>
<td>IT_PROG</td>
<td>60</td>
</tr>
<tr>
<td>21-May-1991</td>
<td>104</td>
<td>-</td>
<td>-</td>
<td>IT_PROG</td>
<td>60</td>
</tr>
<tr>
<td>07-Feb-1999</td>
<td>107</td>
<td>-</td>
<td>-</td>
<td>IT_PROG</td>
<td>60</td>
</tr>
<tr>
<td>-</td>
<td>114</td>
<td>24-Mar-1998</td>
<td>31-Dec-1999</td>
<td>ST_CLERK</td>
<td>50</td>
</tr>
<tr>
<td>-</td>
<td>122</td>
<td>01-Jan-1999</td>
<td>31-Dec-1999</td>
<td>ST_CLERK</td>
<td>50</td>
</tr>
<tr>
<td>16-Nov-1999</td>
<td>124</td>
<td>-</td>
<td>-</td>
<td>ST_MAN</td>
<td>50</td>
</tr>
<tr>
<td>17-Oct-1995</td>
<td>141</td>
<td>-</td>
<td>-</td>
<td>ST_CLERK</td>
<td>50</td>
</tr>
<tr>
<td>29-Jan-1997</td>
<td>142</td>
<td>-</td>
<td>-</td>
<td>ST_CLERK</td>
<td>50</td>
</tr>
<tr>
<td>15-Mar-1998</td>
<td>143</td>
<td>-</td>
<td>-</td>
<td>ST_CLERK</td>
<td>50</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody>
</table>

    </body>
    </html>